package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.44

import (
	"context"

	"github.com/Kahono0/simple-go-api/engine"
	"github.com/Kahono0/simple-go-api/graph/model"
	"github.com/Kahono0/simple-go-api/models"
)

// CreateItem is the resolver for the createItem field.
func (r *mutationResolver) CreateItem(ctx context.Context, name string, description *string, price float64) (*model.Item, error) {
	item, err := engine.CreateItem(name, description, price)
	if err != nil {
		return nil, err
	}

	return &model.Item{
		ID:          item.ID.String(),
		Name:        item.Name,
		Description: item.Description,
		Price:       item.Price,
	}, nil
}

// UpdateItem is the resolver for the updateItem field.
func (r *mutationResolver) UpdateItem(ctx context.Context, id string, name *string, description *string, price *float64) (*model.Item, error) {
	item, err := engine.UpdateItem(id, name, description, price)
	if err != nil {
		return nil, err
	}

	return &model.Item{
		ID:          item.ID.String(),
		Name:        item.Name,
		Description: item.Description,
		Price:       item.Price,
	}, nil
}

// DeleteItem is the resolver for the deleteItem field.
func (r *mutationResolver) DeleteItem(ctx context.Context, id string) (*model.Item, error) {
	return nil, engine.DeleteItem(id)
}

// CreateOrder is the resolver for the createOrder field.
func (r *mutationResolver) CreateOrder(ctx context.Context, input model.OrderInput) (*model.Order, error) {
	user := ctx.Value("user").(*models.User)
	order, err := engine.CreateOrder(user.ID, input.Items, input.Contact)
	if err != nil {
		return nil, err
	}

	items := make([]*model.Item, len(order.Items))
	for i, item := range order.Items {
		items[i] = &model.Item{
			ID:          item.ID.String(),
			Name:        item.Name,
			Description: item.Description,
			Price:       item.Price,
		}
	}

	return &model.Order{
		ID:        order.ID.String(),
		Items:     items,
		Total:     order.Total,
		Status:    order.Status,
		CreatedAt: order.CreatedAt.String(),
	}, nil
}

// UpdateOrder is the resolver for the updateOrder field.
func (r *mutationResolver) UpdateOrder(ctx context.Context, id string, status string) (*model.Order, error) {
	order, err := engine.UpdateOrder(id, status)
	if err != nil {
		return nil, err
	}

	items := make([]*model.Item, len(order.Items))
	for i, item := range order.Items {
		items[i] = &model.Item{
			ID:          item.ID.String(),
			Name:        item.Name,
			Description: item.Description,
			Price:       item.Price,
		}
	}

	return &model.Order{
		ID:        order.ID.String(),
		Items:     items,
		Total:     order.Total,
		Status:    order.Status,
		CreatedAt: order.CreatedAt.String(),
	}, nil
}

// DeleteOrder is the resolver for the deleteOrder field.
func (r *mutationResolver) DeleteOrder(ctx context.Context, id string) (*model.Order, error) {
	return nil, engine.DeleteOrder(id)
}

// Items is the resolver for the items field.
func (r *queryResolver) Items(ctx context.Context) ([]*model.Item, error) {
	items, err := engine.GetItems()
	if err != nil {
		return nil, err
	}

	result := make([]*model.Item, len(items))
	for i, item := range items {
		result[i] = &model.Item{
			ID:          item.ID.String(),
			Name:        item.Name,
			Description: item.Description,
			Price:       item.Price,
		}
	}

	return result, nil
}

// Item is the resolver for the item field.
func (r *queryResolver) Item(ctx context.Context, id string) (*model.Item, error) {
	item, err := engine.GetItem(id)
	if err != nil {
		return nil, err
	}

	return &model.Item{
		ID:          item.ID.String(),
		Name:        item.Name,
		Description: item.Description,
		Price:       item.Price,
	}, nil
}

// Orders is the resolver for the orders field.
func (r *queryResolver) Orders(ctx context.Context) ([]*model.Order, error) {
	user := ctx.Value("user").(*models.User)
	orders, err := engine.GetOrdersByUserID(user.ID)
	if err != nil {
		return nil, err
	}

	result := make([]*model.Order, len(orders))
	for i, order := range orders {

		items := make([]*model.Item, len(order.Items))
		for i, item := range order.Items {
			items[i] = &model.Item{
				ID:          item.ID.String(),
				Name:        item.Name,
				Description: item.Description,
				Price:       item.Price,
			}
		}

		result[i] = &model.Order{
			ID:        order.ID.String(),
			Items:     items,
			Total:     order.Total,
			Status:    order.Status,
			CreatedAt: order.CreatedAt.String(),
		}
	}

	return result, nil
}

// Order is the resolver for the order field.
func (r *queryResolver) Order(ctx context.Context, id string) (*model.Order, error) {
	order, err := engine.GetOrder(id)
	if err != nil {
		return nil, err
	}

	items := make([]*model.Item, len(order.Items))
	for i, item := range order.Items {
		items[i] = &model.Item{
			ID:          item.ID.String(),
			Name:        item.Name,
			Description: item.Description,
			Price:       item.Price,
		}
	}

	return &model.Order{
		ID:        order.ID.String(),
		Items:     items,
		Total:     order.Total,
		Status:    order.Status,
		CreatedAt: order.CreatedAt.String(),
	}, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	//get user from context
	user := ctx.Value("user").(*models.User)
	return &model.User{
		ID:    user.ID,
		Email: user.Email,
		Name:  user.Name,
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
